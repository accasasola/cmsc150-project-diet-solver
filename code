// lab07_surname_A.c
// Compile:  gcc -O2 -Wall -o lab07_A lab07_surname_A.c
// Run:      ./lab07_A   (expects input.txt in same folder)

#include <stdio.h>
#include <stdlib.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/types.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>

#define FTOK_PATH "."          // any existing path; both programs must match
#define PROJ_META  0x11
#define PROJ_A     0x22
#define PROJ_B     0x33
#define PROJ_RES   0x44

typedef struct {
    int a_rows, a_cols;
    int b_rows, b_cols;
    int total_cells;         // a_rows * b_cols  (or -1 if incompatible)
    volatile int computed;   // number of C cells already written
    volatile int readyA;     // A finished loading matrices & sizes
} Meta;

static int idx(int r, int c, int ncols) { return r * ncols + c; }

static void die(const char* msg) {
    perror(msg);
    exit(EXIT_FAILURE);
}

int main(void) {
    // ---------- 1) Read input.txt ----------
    FILE *fp = fopen("input.txt", "r");
    if (!fp) die("fopen(input.txt)");

    int ar, ac; // A dims
    if (fscanf(fp, "%d %d", &ar, &ac) != 2) { fprintf(stderr, "Bad input for A dims\n"); return 1; }

    int *A = (int*)malloc(sizeof(int) * ar * ac);
    for (int i = 0; i < ar; ++i)
        for (int j = 0; j < ac; ++j)
            if (fscanf(fp, "%d", &A[idx(i,j,ac)]) != 1) { fprintf(stderr, "Bad input for A elems\n"); return 1; }

    int br, bc; // B dims
    if (fscanf(fp, "%d %d", &br, &bc) != 2) { fprintf(stderr, "Bad input for B dims\n"); return 1; }

    int *B = (int*)malloc(sizeof(int) * br * bc);
    for (int i = 0; i < br; ++i)
        for (int j = 0; j < bc; ++j)
            if (fscanf(fp, "%d", &B[idx(i,j,bc)]) != 1) { fprintf(stderr, "Bad input for B elems\n"); return 1; }

    fclose(fp);

    // ---------- 2) Create/attach shared memory segments ----------
    key_t kMeta = ftok(FTOK_PATH, PROJ_META);
    key_t kA    = ftok(FTOK_PATH, PROJ_A);
    key_t kB    = ftok(FTOK_PATH, PROJ_B);
    key_t kRes  = ftok(FTOK_PATH, PROJ_RES);
    if (kMeta==-1 || kA==-1 || kB==-1 || kRes==-1) die("ftok");

    int shmidMeta = shmget(kMeta, sizeof(Meta), IPC_CREAT | 0666);
    if (shmidMeta < 0) die("shmget meta");
    Meta *meta = (Meta*)shmat(shmidMeta, NULL, 0);
    if (meta == (void*)-1) die("shmat meta");

    // Put sizes (and error flag if incompatible)
    meta->a_rows = ar; meta->a_cols = ac;
    meta->b_rows = br; meta->b_cols = bc;
    meta->computed = 0;
    if (ac != br) {
        meta->total_cells = -1;   // signal error to B
        meta->readyA = 1;
        fprintf(stderr, "Error: incompatible dimensions (A cols != B rows)\n");
        // We still publish the error so B can print the message and cleanup.
        return 0;
    }
    meta->total_cells = ar * bc;
    meta->readyA = 0; // will set to 1 after all SHMs are filled

    // A matrix segment
    int shmidA = shmget(kA, sizeof(int) * ar * ac, IPC_CREAT | 0666);
    if (shmidA < 0) die("shmget A");
    int *shA = (int*)shmat(shmidA, NULL, 0);
    if (shA == (void*)-1) die("shmat A");

    // B matrix segment
    int shmidB = shmget(kB, sizeof(int) * br * bc, IPC_CREAT | 0666);
    if (shmidB < 0) die("shmget B");
    int *shB = (int*)shmat(shmidB, NULL, 0);
    if (shB == (void*)-1) die("shmat B");

    // Result matrix segment (initialized to 0)
    int shmidR = shmget(kRes, sizeof(int) * ar * bc, IPC_CREAT | 0666);
    if (shmidR < 0) die("shmget Res");
    int *shR = (int*)shmat(shmidR, NULL, 0);
    if (shR == (void*)-1) die("shmat Res");
    memset(shR, 0, sizeof(int) * ar * bc);

    // Copy A and B into shared memory
    memcpy(shA, A, sizeof(int) * ar * ac);
    memcpy(shB, B, sizeof(int) * br * bc);

    free(A); free(B);

    // Publish that A finished setting things up
    meta->readyA = 1;

    // ---------- 3) Compute left half (and middle if odd) ----------
    int left_cols = (bc + 1) / 2; // ceil(bc/2)
    for (int i = 0; i < ar; ++i) {
        for (int j = 0; j < left_cols; ++j) {
            long sum = 0;
            for (int k = 0; k < ac; ++k)
                sum += shA[idx(i,k,ac)] * shB[idx(k,j,bc)];
            shR[idx(i,j,bc)] = (int)sum;
            __sync_fetch_and_add((int*)&meta->computed, 1); // atomic add (GCC/Clang)
        }
    }

    // A exits; B will print and clean up.
    return 0;
}
